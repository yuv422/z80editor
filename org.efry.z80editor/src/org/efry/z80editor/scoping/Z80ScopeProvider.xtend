/*
 * generated by Xtext
 */
package org.efry.z80editor.scoping

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.impl.SimpleLocalScopeProvider
import org.eclipse.xtext.scoping.Scopes
import org.efry.z80editor.z80.EntityRef
import org.efry.z80editor.z80.LabelType
import org.efry.z80editor.z80.DotExpression
import org.efry.z80editor.z80.Macro
import org.efry.z80editor.z80.Struct
import org.efry.z80editor.z80.VarStruct

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class Z80ScopeProvider extends AbstractDeclarativeScopeProvider {

	//@Inject
	//private IGlobalScopeProvider globalScopeProvider;
	
	@Inject
	private SimpleLocalScopeProvider localScopeProvider;
//	
//	def IScope scope_NumericLiteral_referencedObj(EObject varName, EReference ref) {
//
//		localScopeProvider.getScope(varName, ref);
//	}

/*
	def IScope scope_NumericLiteral_referencedObj(EObject varName, EReference ref) {
		
		var locals = EcoreUtil2::getAllContentsOfType(EcoreUtil2::getRootContainer(varName), typeof(VarName));
		Scopes::scopeFor(locals, globalScopeProvider.getScope(varName.eResource, ref, null));		
	}
	*/
    
	def IScope scope_DotExpression_tail(DotExpression exp, EReference ref) {
	        //IScope::NULLSCOPE
	    //Scopes::scopeFor(exp.entity.ref.definitions);
	    
	    val head = exp.ref;
        switch (head) {
            EntityRef : {
                var label = head.entity
                var struct = null as Struct
                if(label.eContainer instanceof Struct) {
                    struct = label.eContainer as Struct
                } else if(label.eContainer instanceof VarStruct) {
                    var varStruct = label.eContainer as VarStruct
                    var structLabel = varStruct.structRef
                    if(structLabel.eContainer instanceof Struct) {
                        struct = structLabel.eContainer as Struct
                    }
                }
                
                if(struct != null) {
                    return Scopes::scopeFor(struct.definitions)
                }
//                    var struct = head.entity
//                    if(struct != null) {
//                        if(struct.definitions != null && !struct.definitions.empty) {
//                            Scopes::scopeFor(struct.definitions)
//                        } else {
//                            struct = struct.ref as LabelType
//                            Scopes::scopeFor(struct.definitions)
//                        }
//                    }
        IScope::NULLSCOPE
                }
            DotExpression : {
                val tail = head.tail
                switch (tail) {
 //                   Attribute : IScope::NULLSCOPE
                    default: IScope::NULLSCOPE
                }
            }
             
            default: IScope::NULLSCOPE
        }

//        val head = exp.entity;
//        switch (head) {
//            EntityRef : Scopes::scopeFor(head.entity.features)
//            DotExpression : {
//                val tail = head.tail
//                switch (tail) {
//                    Attribute : IScope::NULLSCOPE
//                    Reference : Scopes::scopeFor(tail.type.features)
//                    default: IScope::NULLSCOPE
//                }
//            }
//             
//            default: IScope::NULLSCOPE
//        }

    }
    
    def IScope scope_LabelType(Macro macro, EReference ref) {
        if(macro.macroArgs != null && !macro.macroArgs.empty) {
            Scopes::scopeFor(macro.macroArgs, localScopeProvider.getScope(macro, ref));
        }
    }
}
