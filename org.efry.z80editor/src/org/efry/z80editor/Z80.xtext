grammar org.efry.z80editor.Z80 with org.eclipse.xtext.common.Terminals

generate z80 "http://www.efry.org/z80editor/Z80"

Z80Model:
    commands+=Line*;

terminal REGISTER_A: 'a';
terminal REGISTER_B: 'b';
REGISTER_C: 'c'; //cannot be a terminal because it clashes with the 'C'arry flag.
terminal REGISTER_D: 'd';
terminal REGISTER_E: 'e';
terminal REGISTER_H: 'h';
terminal REGISTER_I: 'i';
terminal REGISTER_L: 'l';
terminal REGISTER_R: 'r';

terminal REGISTER_AF: 'af';
terminal REGISTER_AF_SHADOW: 'af\'';
terminal REGISTER_BC: 'bc';
terminal REGISTER_DE: 'de';
terminal REGISTER_HL: 'hl';
terminal REGISTER_IX: 'ix';
terminal REGISTER_IY: 'iy';
terminal REGISTER_SP: 'sp';

terminal NEWLINE:
// New line on DOS or Unix
    '\r'? '\n';

Line:
	(Macro | MacroUsage | Smstag | EmptyFill | Asm | EndAsm | Define | Redefine | MemoryMap | RomBankMap | Sdsctag | Bank | Org | Section | Struct | EnumCmd | RamSection | Repeat | Rept | Asc | Dsb | Dsw | Db | Dw | IncludeType | IfCmd | Label | Asciitable | Command) NEWLINE | (Label c=Command NEWLINE) | {EmptyLine} NEWLINE;

//Lines: first=Line extra+=SubsequentLine*;
//SubsequentLine: nl=NEWLINE line=Line?;
Macro: '.macro' MacroName (('nargs' INT)|('args' ID (',' ID)?))? NEWLINE lines+=Line* '.endm';
MacroName: name=ID;

MacroUsage: ref=[MacroName] (first=NumericLiteral (',' others+=NumericLiteral)*)?;

Smstag: {SmsTagType} '.smstag' ;

EmptyFill: '.emptyfill' NUMBER;
Asm: {asmDirective} '.asm';
EndAsm: {asmDirective} '.endasm';

Define: ('.define'|'.def') name=VarName expr=Expression;
Redefine: ('.redefine'|'.redef') name=VarName expr=Expression;

IfCmd: '.if' lop=IfOperand comparison=IfOperator rop=IfOperand NEWLINE block+=Line+ ('.else' NEWLINE elseBlock+=Line+)? '.endif';
IfOperator: ('<'|'<='|'>'|'>='|'=='|'!=');
IfOperand: number=NUMBER|str=ID;

MemoryMap: '.memorymap' NEWLINE cmds+=MemoryMapCommands+ '.endme';
MemoryMapCommands: ('defaultslot' INT NEWLINE) |
	('slotsize' (HEX|INT) NEWLINE) |
	('slot' (HEX|INT) (HEX|INT)? NEWLINE)
;

RomBankMap: '.rombankmap' NEWLINE cmds+=RomBankCommands+ '.endro';
RomBankCommands: ('bankstotal' (INT|HEX) NEWLINE) |
	('banksize' (INT|HEX) NEWLINE) |
	('banks' (INT|HEX) NEWLINE)
;

Rept: '.rept' INT NEWLINE block+=Line+ '.endr';
Repeat: '.repeat' INT NEWLINE block+=Line+ '.endr';

Bank: {BankCmd} '.bank' INT ('slot' slot=INT)?;
Org: '.org' value=(NUMBER);
Section: '.section' sectionName=STRING? ('size' size=NUMBER)? ('align' align=NUMBER)? ('force'|'semifree'|'free'|'superfree'|'overwrite')? NEWLINE lines+=Line+ '.ends';

Struct: '.struct' structName=ID NEWLINE definitions+=VarDefinitionStruct* '.endst';
EnumCmd: '.enum' startAddress=NumericLiteral order=('asc'|'desc')? 'export'? NEWLINE definitions+=VarDefinitionEnum* '.ende';

RamSection: '.ramsection' sectionName=STRING ('bank' bank=NUMBER)? ('slot' slot=NUMBER)? NEWLINE definitions+=VarDefinition* '.ends';


VarDefinitionEnum: {VarDef} (varName=VarName ':'? type=(EnumType))? NEWLINE;

EnumType: (VarTypeByte|VarTypeWord|VarTypeByteString|VarTypeWordString|VarTypeStruct);

VarDefinitionStruct: {VarDef} (varName=VarName type=(VarTypeByte|VarTypeWord|VarTypeByteString|VarTypeWordString))? NEWLINE;
VarDefinition: {VarDef} (varName=VarName type=(VarTypeByte|VarTypeWord|VarTypeByteString|VarTypeWordString|VarTypeStruct))? NEWLINE;

VarTypeStruct: {VarType} type=('.instanceof'|'instanceof') structName=VarName repeatAmount=INT?;
VarTypeByte: {VarType} type=('.db'|'db');
VarTypeWord: {VarType} type=('.dw'|'dw');
VarTypeByteString: {VarType} type=('.ds'|'ds'|'.dsb'|'dsb') size=Expression (',' initalValue=Expression)?;
VarTypeWordString: {VarType} type=('.dsw'|'dsw') size=Expression (',' initalValue=Expression)?;

Asciitable: ('.asciitable'|'.asctable') NEWLINE definitions+=MapTableEntry+ '.enda';

MapTableEntry: {MapDef} ('map' from=AsciiChar ('to' to=AsciiChar)? '=' startOffset=NUMBER)? NEWLINE;
AsciiChar: (intVal=NUMBER|char=STRING);

Asc: '.asc' value=STRING;

Dsb: ('.dsb'|'.ds') count=NUMBER ',' value=NUMBER;
Dsw: '.dsw' count=NUMBER ',' value=NUMBER;

Db: {DbCmd} ('.db'|'.byt') (first=DbDataType (numLitData=DbAdditionalValuesSeparatedBySpace|exprData=DbAdditionalValuesSeparatedByComma)?);
DbAdditionalValuesSeparatedBySpace: others+=DbNonExprDataType+;
DbAdditionalValuesSeparatedByComma: others+=DbAdditionalValueType+;
DbDataType: expr=Expression|str=STRING;
DbNonExprDataType hidden(): MINUS? NumericLiteral;
Dw: {DwCmd} '.dw' first=NumericLiteral others+=DwAdditionalValueType*;
DbAdditionalValueType: ',' value=DbDataType;
DwAdditionalValueType: ','? value=NumericLiteral;

IncludeType: inc=(Include|Incbin);
Include: '.include' file=STRING;
Incbin: '.incbin' file=STRING;

Sdsctag: {SdscTagCmd} '.sdsctag' INT('.'INT)? ',' (STRING|ID) ',' (STRING|ID) ',' (STRING|ID); //FIXME need to make a better version number type

//terminal UnHandledWlaDxCommand: '.' ID !('\n'|'\r')*; //FIXME

PLUS: '+';
terminal PLUSLABEL: '+:';
terminal PLUSPLUS: '+''+'+;

terminal MINUSLABEL: '-:';
terminal MINUS: '-';
terminal MINUSMINUS: '-''-'+;

BANKLABEL hidden(): ':'referencedObj=[VarName];

VarName: name=ID;

Label hidden() : {LabelType} (PLUSLABEL|MINUSLABEL|((varName=VarName|PLUSPLUS|MINUSMINUS)':'));

Expression returns Expr:
    BitwiseOp;

BitwiseOp returns Expr:
    BitshiftOp
    ({BinaryExpr.left=current} op1=('|' | '&' | '~') right=Addition)*;
    
BitshiftOp returns Expr:
    Addition
    ({BinaryExpr.left=current} op1=('<<' | '>>') right=Addition)*;

Addition returns Expr:
    Multiplication
    ({BinaryExpr.left=current} op1=(PLUS | MINUS) right=Multiplication)*;

Multiplication returns Expr:
    PrimaryExpression
    ({BinaryExpr.left=current} op1=('*' | '/' | '#') right=PrimaryExpression)*;

PrimaryExpression returns Expr:
    '(' Expression ')' |
    {NumLiteral} sign=MINUS? value=NumericLiteral;
      
Command:
     (Adc|Add|And|Bit|Call|Ccf|Cp|Cpd|Cpdr|Cpi|Cpir|Cpl|Daa|Dec|Di|Djnz|Ei|Ex|Exx|Halt|Im|In|Inc|Ind|Indr|Ini|Inir|Jp|Jr|Ld|Ldd|Lddr|Ldi|Ldir|Neg|Nop|Or|Otdr|Otir|Out|Outi|Outd|Pop|Push|Res|Ret|Reti|Retn|Rl|Rla|Rlc|Rlca|Rld|RrCmd|Rra|Rrc|Rrca|Rrd|Rst|Sbc|Scf|Set|Sla|Sra|Srl|Sub|Xor)
;

DoubleRegisters:
    (REGISTER_AF|REGISTER_BC|REGISTER_DE|REGISTER_HL|xx)
;

Adc: {Operation} opcode='adc' ((reg=REGISTER_A ',' rightOp=s)|(reg=REGISTER_HL ',' rightOp=ss));
Add: {Operation} opcode='add' ((reg=REGISTER_A ',' rightOp=s)|(reg=REGISTER_HL ',' rightOp=ss)|(reg=REGISTER_IX ',' rightOp=pp)|(reg=REGISTER_IY ',' rightOp=rr));
And: {Operation} opcode='and' operand=s;
Bit: {Operation} opcode='bit' leftOp=B ',' rightOp=m;
Call: {Operation} opcode='call' (condition=CC ',')? (lit=NumericLiteral|PLUS|PLUSPLUS|MINUS|MINUSMINUS);
Ccf: {Operation} opcode='ccf';
Cp: {Operation} opcode='cp' operand=s;
Cpd: {Operation} opcode='cpd';
Cpdr: {Operation} opcode='cpdr';
Cpi: {Operation} opcode='cpi';
Cpir: {Operation} opcode='cpir';
Cpl: {Operation} opcode='cpl';
Daa: {Operation} opcode='daa';
Dec: {Operation} opcode='dec' operand=dd;
Di: {Operation} opcode='di';
Djnz: {Operation} opcode='djnz' operand=e;
Ei: {Operation} opcode='ei';
Ex: {Operation} opcode='ex' ((indirectOp=SPIndirect ',' rightOp=ee)|(reg=REGISTER_AF ',' REGISTER_AF_SHADOW)|(reg=REGISTER_DE ',' REGISTER_HL));
Exx: {Operation} opcode='exx';
Halt: {Operation} opcode='halt';
Im: {Operation} opcode='im' literal=NumericLiteral;
In: {Operation} opcode='in' ((reg=REGISTER_A ',' rightIndirectOp=NumericLiteralIndirect)|(leftOp=r ',' rightIndirectOp=CIndirect));
Inc: {Operation} opcode='inc' operand=incOps;
Ind: {Operation} opcode='ind';
Indr: {Operation} opcode='indr';
Ini: {Operation} opcode='ini';
Inir: {Operation} opcode='inir';
Jp: {Operation} opcode='jp' (indirectOp=(IndexIndirect|HLIndirect)|((condition=CC ',')? (lit=NumericLiteral|PLUS|PLUSPLUS|MINUS|MINUSMINUS)));
Jr: {Operation} opcode='jr' (condition=jrCc ',')? operand=e;
Ld: {Operation} opcode='ld' ((reg=REGISTER_I ',' REGISTER_A)|(reg=REGISTER_R ',' REGISTER_A)|=>(leftOp=dst ',' rightOp=src)); //FIXME src shouldn't contain 'i','r'. It also needs some changes to handle ix,iy in dst. It should look like this 'ld' ((dst ',' src)|(REGISTER_A ',' ('i'|'r')))
Ldd: {Operation} opcode='ldd';
Lddr: {Operation} opcode='lddr';
Ldi: {Operation} opcode='ldi';
Ldir: {Operation} opcode='ldir';
Neg: {Operation} opcode='neg';
Nop: {Operation} opcode='nop';
Or: {Operation} opcode='or' operand=s;
Otdr: {Operation} opcode='otdr';
Otir: {Operation} opcode='otir';
Out: {Operation} opcode='out' ((indirectOp=CIndirect ',' rightOp=r)|(indirectOp=NumericLiteralIndirect ',' REGISTER_A));
Outd: {Operation} opcode='outd';
Outi: {Operation} opcode='outi';
Pop: {Operation} opcode='pop' reg=DoubleRegisters;
Push: {Operation} opcode='push' reg=DoubleRegisters;
Res: {Operation} opcode='res' leftOp=B ',' rightOp=m;
Ret: {Operation} opcode='ret' condition=CC?;
Reti: {Operation} opcode='reti';
Retn: {Operation} opcode='retn';
Rl: {Operation} opcode='rl' operand=m;
Rla: {Operation} opcode='rla';
Rlc: {Operation} opcode='rlc' operand=m;
Rlca: {Operation} opcode='rlca';
Rld: {Operation} opcode='rld';
RrCmd: {Operation} opcode='rr' operand=m;
Rra: {Operation} opcode='rra';
Rrc: {Operation} opcode='rrc' operand=m;
Rrca: {Operation} opcode='rrca';
Rrd: {Operation} opcode='rrd';
Rst: {Operation} opcode='rst' operand=p;
Sbc: {Operation} opcode='sbc' ((reg=REGISTER_A ',' rightOp=s)|(reg=REGISTER_HL ',' rightOp=ss));
Scf: {Operation} opcode='scf';
Set: {Operation} opcode='set' leftOp=B ',' rightOp=m;
Sla: {Operation} opcode='sla' operand=m;
Sra: {Operation} opcode='sra' operand=m;
Srl: {Operation} opcode='srl' operand=m;
Sub: {Operation} opcode='sub' operand=s;
Xor: {Operation} opcode='xor' operand=s;

terminal SL_COMMENT     : ';' !('\n'|'\r')*;
terminal WS            : (' '|'\t')+;

MacroNumericArg hidden(): arg='\\'INT;

BitOperand: {BitType} value=INT;//Must be in range 0..7 This is checked for by a validator
B returns Operand: bitType=BitOperand;
NumericLiteral : BANKLABEL|referencedObj=[LabelType]|NUMBER|MacroNumericArg; //ID
NUMBER: i=INT|str=(HEX|BINARY);
NegNumber hidden(): MINUS? NUMBER;

terminal HEX: ('$'('a'..'f'|'A'..'F'|'0'..'9')+)|('0'..'9'('a'..'f'|'A'..'F'|'0'..'9')*'h');
terminal BINARY: '%'('0'..'1')+;

AnonymousLabel: PLUS|PLUSPLUS|MINUS|MINUSMINUS;

CIndirect returns Operand: ('[' reg=REGISTER_C ']')|('(' reg=REGISTER_C ')');
BCIndirect returns Operand: ('[' reg=REGISTER_BC ']')|('(' reg=REGISTER_BC ')');
DEIndirect returns Operand: ('[' reg=REGISTER_DE ']')|('(' reg=REGISTER_DE ')');
HLIndirect returns Operand: ('[' reg=REGISTER_HL ']')|('(' reg=REGISTER_HL ')');
SPIndirect returns Operand: ('[' reg=REGISTER_SP ']')|('(' reg=REGISTER_SP ')');
NumericLiteralIndirect returns Operand: ('[' lit=NumericLiteral ']')|('(' =>lit=NumericLiteral ')');

IndexIndirectPlusOffset returns Operand: ('[' indexPlusOffset=IndexPlusOffset ']')|('(' indexPlusOffset=IndexPlusOffset ')');
IndexIndirect returns Operand: ('[' reg=xx ']')|('(' reg=xx ')');

IndexPlusOffset returns Operand: reg=xx offset=SignedByteOffset;
SignedByteOffset: sign=(PLUS|MINUS) value=NUMBER; //Must be in the range -128..+127 This is checked for by a validator

CC: 'c'|'m'|'nc'|'nz'|'p'|'pe'|'po'|'z';
jrCc: 'c'|'nc'|'nz'|'z';

dst returns Operand: =>indirectOp=NumericLiteralIndirect|op=(s|ss)|indirectOp=(BCIndirect|DEIndirect)|reg=(xx);

e returns Operand: (lit=NumericLiteral|anonLabel=(PLUS|PLUSPLUS|MINUS|MINUSMINUS)); //fixme -126 to +129
m returns Operand: op=(r)|indirectOp=(HLIndirect|IndexIndirectPlusOffset);
p returns Operand: intType=NUMBER; //FIXME need to restrict to $0000, $0008, $0010, $0018, $0020, $0028, $0030 or $0038 
pp returns Operand: reg=(REGISTER_BC|REGISTER_DE|REGISTER_IX|REGISTER_SP);
r returns Operand: reg=(REGISTER_A|REGISTER_B|REGISTER_C|REGISTER_D|REGISTER_E|REGISTER_H|REGISTER_L);
rr returns Operand: reg=(REGISTER_BC|REGISTER_DE|REGISTER_IY|REGISTER_SP);
s returns Operand:  op=m|expr=Expression;
ss returns Operand: reg=(REGISTER_BC|REGISTER_DE|REGISTER_HL|REGISTER_SP);
src returns Operand: =>indirectOp=NumericLiteralIndirect|op=(s|ss)|indirectOp=(BCIndirect|DEIndirect)|reg=(REGISTER_I|REGISTER_R|xx);
xx: (REGISTER_IX|REGISTER_IY);
dd returns Operand: op=(m|ss)|reg=xx;
ee returns Operand: reg=(REGISTER_HL|xx);
incOps returns Operand: op=(r|ss|IndexIndirectPlusOffset)|reg=(xx)|indirectOp=HLIndirect;